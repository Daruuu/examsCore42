
ğŸ”‘ 1. JerarquÃ­a de operaciones

MultiplicaciÃ³n (*) tiene mÃ¡s prioridad que suma (+).

ParÃ©ntesis tienen mÃ¡s prioridad aÃºn, forzando a evaluar lo que hay dentro primero.
ğŸ‘‰ Esto significa que no puedes leer la expresiÃ³n de izquierda a derecha â€œa peloâ€; necesitas respetar esta jerarquÃ­a.

ğŸ”‘ 2. RecursiÃ³n y Recursive Descent Parsing

El cÃ³digo estÃ¡ orientado a un parser recursivo.
La idea es dividir en funciones, por niveles de precedencia:

	parse_expr â†’ maneja suma y lo mÃ¡s general.

	parse_term â†’ maneja multiplicaciÃ³n.

	parse_factor â†’ maneja nÃºmeros o expresiones entre parÃ©ntesis.

ğŸ‘‰ Estructura tÃ­pica:

expr    := term { '+' term }
term    := factor { '*' factor }
factor  := DIGIT | '(' expr ')'

ğŸ”‘ 3. Ãrbol sintÃ¡ctico (AST)

Cada operaciÃ³n se guarda como un Ã¡rbol:

Nodo VAL â†’ un nÃºmero.

Nodo ADD â†’ suma de dos subÃ¡rboles.

Nodo MULTI â†’ multiplicaciÃ³n de dos subÃ¡rboles.

Ejemplo:
3 + 4 * 5

      ADD
     /   \
   VAL=3  MULTI
          /   \
       VAL=4  VAL=5

ğŸ”‘ 4. Manejo de errores

Tienes que devolver errores cuando:

Aparece un carÃ¡cter inesperado (no dÃ­gito, +, *, ( o )).

Falta cerrar parÃ©ntesis.

La expresiÃ³n termina de forma abrupta ("1+").
ğŸ‘‰ FÃ­jate que la funciÃ³n unexpected ya estÃ¡ definida para ayudarte.

ğŸ”‘ 5. Funciones de ayuda

accept â†’ avanza el puntero si encuentra un carÃ¡cter esperado.

expect â†’ como accept, pero da error si no estÃ¡ lo esperado.

Estas son bÃ¡sicas para consumir la cadena mientras se parsea.

ğŸ”‘ 6. EvaluaciÃ³n del Ã¡rbol

Ya estÃ¡ implementada (eval_tree). Una vez construido el Ã¡rbol, solo tienes que recorrerlo recursivamente.


